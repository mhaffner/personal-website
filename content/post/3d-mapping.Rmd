---
date: "2019-06-01T00:00:00"
draft : true
tags : ["Geography", "web mapping", "3D", "Leaflet", "R", "raster", "rgl"]
title : "A simple 3D mapping example in R"
summary : "3D representation of Eau Claire, Wisconsin"
math : false
comments : true
---

This is a simple demonstration of using R and (mostly) automated methods for
extracting, cleaning, and mapping digital elevation model (DEM) data. This first
chunk relies on some fairly standard R libraries with one exception -
`haffutils` - which is a package made up of simple wrappers and whatnot that I
mostly started to become more familiar with creating R packages. It can be
installed with `devtools::install_gitlab("mhaffner/haffutils")`.

```{r echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}
library(haffutils)
library(raster)
library(rgdal)
library(sf)
library(tmap)
library(rgl)
library(rasterVis)

## the rmd way to setwd()
knitr::opts_knit$set(root.dir = "/home/matt/git-repos/3d-mapping/data/")
```

First, I download/unzip some data from the U.S. Census and the Wisconsin
Department of Natural Resources (WDNR).

```{r echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}
## download and unzip dem; wisconin dnr hosts this but not for direct download,
## so i put it in a git repo
dl_file("https://gitlab.com/mhaffner/data/raw/master/DEM_30m.zip")

## cartographic boundary files from the US Census
dl_file("https://www2.census.gov/geo/tiger/GENZ2017/shp/cb_2017_us_county_500k.zip")

## use readAll to load the raster in memory; it's too large otherwise. subsets
## of this data (i.e. couties) can be loaded in just fine.
wi.dem <- readAll(raster("DEM_30m/demgw930/"))

## load county boundaries and transform crs into the one used by dem
wi.counties <- readOGR("cb_2017_us_county_500k.shp", verbose = FALSE) %>%
  subset(STATEFP == 55) %>%
  spTransform(., crs(wi.dem))

## plot them
plot(wi.dem)
plot(wi.counties, add = TRUE)
```

The counties here are just used for visualization in the map above. I did some
experimenting with Buffalo and Eau Claire counties, but with an extent that
large it's hard to see meaningful, human-scale elevation change. So I then
extracted Urban Areas from the U.S. Census to focus on a smaller extent (city of
Eau Claire).

```{r echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}
## get us urban areas from census
dl_file("www2.census.gov/geo/tiger/GENZ2017/shp/cb_2017_us_ua10_500k.zip")

places <- readOGR("cb_2017_us_ua10_500k.shp", verbose = FALSE)

## get just eau claire and transform crs into the crs of the dem
ec <- places[places$NAME10 == 'Eau Claire, WI',] %>%
  spTransform(., crs(wi.dem))
```

Now let's plot the DEM of just the city just to be sure it looks ok.

```{r echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}
## clip raster to eau claire; here it makes sense to not use a mask as well
## since it would result in a weirdly shaped area, and a rectangle is more
## aesthetically pleasing
ec.dem <- crop(wi.dem, ec)

## plot
plot(ec.dem)
```

Here's the fun part. An interactive 3D map of the DEM is created with the `rgl`
library and saved as an html widget.

```{r echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE}
## color definition of each point of the surface
height <- (max(ec.dem.mat, na.rm = TRUE) - min(ec.dem.mat, na.rm = TRUE))/max(ec.dem.mat, na.rm = TRUE)
r.prop <- height
g.prop <- 0
b.prop <- 1 - height
color  <- rgb(r.prop, g.prop, b.prop, maxColorValue=1)
col <- terrain.colors(10)[cut(ec.dem.mat, breaks = 10)]

## convert raster to matrix
ec.dem.mat <- as.matrix(ec.dem)

## use a function to create the 3d scene
create_3d <- function() {
    ## intialize rgl device; similar concept to png() and related things
    open3d()
    
    ## create 3d plot
    rgl::persp3d(ec.dem.mat, col = col)
    
    ## change scaling; TODO: figure out how to automate this
    x.scale <- extent(ec.dem)[2] - extent(ec.dem)[1]
    y.scale <- extent(ec.dem)[4] - extent(ec.dem)[3]
    aspect3d(y.scale, x.scale, 600)
}

## execute
create_3d()

## for some reason this takes forever with htmlwidgets::saveWidget
htmltools::save_html(rglwidget(), "3d.html")
```

For some 

From here it would be easy to layer polylines or points on top of the DEM to
display other spatial data. There are a few ways this all could be improved
though:

- The DEM's resolution is only 30m which is desirable for a proof of concept
  (computational and storage issues are incurred by 10m) but not useful for many
  analyses.
- Scaling the DEM is currently being done manually; I've been modifying the
  z-scale to taste in my examples.
